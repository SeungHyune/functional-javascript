<script src="../lib/fx.js"></script>

## async/await

<script>
    function delay(a){
        return new Promise(resolve => setTimeout(() => resolve(a), 500));
    }

    async function delayIdentity(a){
        await delay(1000);
        return a;
    }

    async function f1(){
        const a = await delayIdentity(10);
        const b = await delayIdentity(5);
        return a + b;
    }

    const pa = f1();
    // (async () => {
    //     log(await pa);
    //     log(await pa);
    //     log(await pa);
    // }) ();

    // f1();
    // f1().then(log);
    // go(f1(), log);
    // (async () => {
    //     log(await f1());
    // }) ();
</script>


## QnA. Array.prototype.map이 있는데 왜 FxJS의 map 함수가 필요한지?

<script>
    async function delayI(a){
        return new Promise(resolve => setTimeout(() => resolve(a), 100));
    }

    async function f2(){
        const list = [1,2,3,4];
        const temp = list.map(async a => await delayI(a * a));
        // log(temp);
        const res = await temp;
        // log(res);
    }
    f2();

    async function f3(){
        const list = [1,2,3,4];
        const temp = map(a => delayI(a * a), list);
        // log(temp);
        const res = await temp;
        // log(res);
    }
    f3();

    function f4(){
        return map(a => delayI(a * a), [1,2,3,4]);
    }

    (async () => {
        log(await f4());
    }) ();
</script>

## QnA. 이제 비동기는 async/await로 제어할 수 있는데 왜 파이프라인이 필요한지?

<script>
    function f5(list){
        return go(list,
            L.map(a => delayI(a * a)),
            L.filter(a => delayI(a % 2)),
            L.map(a => delayI(a + 1)),
            C.take(2),
            reduce((a, b) => delayI(a + b))
        );
    }
    go(f5([1,2,3,4,5,6,7,8]), a => log(a, 'f5'));

    async function f6(list){
        let temp = [];
        for(const a of list) {
            const b = await delayI(a * a);
            if (await delayI(b % 2)){
                const c = await delayI(b + 1);
                temp.push(c);
                if(temp.length === 2) break;
            }
        }
        let res = temp[0], i = 0;
        while(++i < temp.length){
            res += temp[i];
        }
        return res;
    }
    go(f6([1,2,3,4,5,6,7,8]), log);
</script>