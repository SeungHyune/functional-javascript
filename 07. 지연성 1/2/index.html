<script src="../fx.js"></script>

## 이터러블 중심 프로그래밍에서의 지연 평가 (Lazy Evaluation)
- 제때 계산법
- 느긋한 계산법
- 제너레이터/이터레이터 프로토콜을 기반으로 구현

## L.map

<script>
    const L = {};
    L.map = function* (f, iter) {
        for(const a of iter) yield f(a)
    }
    const it = L.map(n => n + 10, [1,2,3,4,5])
    // console.log(it.next())
    // console.log(it.next())
    // console.log(it.next())
    // console.log([...it])
</script>

## filter

<script>
    L.filter = function* (f, iter) {
        for(const a of iter){
            if(f(a)) yield a
        }
    }
    const it2 = L.filter(n => n % 2 === 0, [1,2,3,4,5,6]);
    console.log([...it2]);
</script>

### range, map, filter, take, reduce 중첩 사용

<script>
    const range = l => {
        let i = -1;
        let res = [];
        while(++i < l){
            res.push(i);
        }
        return res;
    }

    const map = curry((f, iter) => {
        let res = [];
        iter = iter[Symbol.iterator]();
        let cur;
        while(!(cur = iter.next()).done){
            const a = cur.value;
            res.push(f(a));
        }
        return res;
    });

    const filter = curry((f, iter) => {
        let res = [];
        iter = iter[Symbol.iterator]();
        let cur;
        while(!(cur = iter.next()).done){
            const a = cur.value;
            if(f(a)) res.push(a);
        }
        return res;
    });

    const take = curry((l, iter) => {
        let res = [];
        iter = iter[Symbol.iterator]();
        let cur;
        while(!(cur = iter.next()).done){
            const a = cur.value;
            res.push(a);
            if(res.length === l) return res
        }
        return res;
    });

    const reduce = curry((f, acc, iter) => {
        if(!iter){
            iter = acc[Symbol.iterator]();
            acc = iter.next().value;
        } else {
            iter = iter[Symbol.iterator]();
        }
        let cur;
        while(!(cur = iter.next()).done){
            const a = cur.value;
            acc = f(acc, a);
        }
        return acc;
    });

    console.time('')
    go(
        range(10000),
        map(n => n + 10),
        filter(n => n % 2),
        take(2),
        console.log
    )
    console.timeEnd('')
    
    
</script>

### L.range, L.map, L.filter, take, reduce 중첩 사용 

<script>
    L.range = function* (l){
        let i = -1;
        while(++i < l){
            yield i;
        }
    }

    L.map = curry(function* (f, iter){
        iter = iter[Symbol.iterator]();
        let cur;
        while(!(cur = iter.next()).done){
            const a = cur.value;
            yield f(a);
        }
    });

    L.filter = curry(function* (f, iter){
        iter = iter[Symbol.iterator]();
        let cur;
        while(!(cur = iter.next()).done){
            const a = cur.value;
            if(f(a)){
                yield a;
            }
        }
    });

    console.time('L')
    go(L.range(10000),
        L.map(n => n + 10),
        L.filter(n => n % 2),
        take(2),
        console.log
    )
    console.timeEnd('L')
</script>